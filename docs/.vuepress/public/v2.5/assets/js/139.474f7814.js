(window.webpackJsonp=window.webpackJsonp||[]).push([[139],{294:function(e,t,a){"use strict";a.r(t);var o=a(0),r=Object(o.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("p",[e._v("PeakDetector")]),e._v(" "),a("h1",{attrs:{id:"peakdetector"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#peakdetector","aria-hidden":"true"}},[e._v("#")]),e._v(" PeakDetector")]),e._v(" "),a("h3",{attrs:{id:"component-type-processor-subcategory-basic-math"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#component-type-processor-subcategory-basic-math","aria-hidden":"true"}},[e._v("#")]),e._v(" Component Type: Processor (Subcategory: Basic Math)")]),e._v(" "),a("p",[e._v("The Peakdetector component can be used to detect peaks (top values of the signal) and valleys (bottom values) in a signal. Additionally it can calculate the time between two peaks or two valleys or between a peak and a valley. Optionally, top and bottom values can be compared with an average of the most recent top / bottom values - this allows to detect only peaks which are for example greater than 150% of the last 5 averaged peak values.")]),e._v(" "),a("p",[a("img",{attrs:{src:"img/peakdetector.png",alt:"Screenshot: PeakDetector plugin",title:"Screenshot: PeakDetector plugin"}}),a("br"),e._v("\nPeakDetector plugin")]),e._v(" "),a("h2",{attrs:{id:"input-port-description"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#input-port-description","aria-hidden":"true"}},[e._v("#")]),e._v(" Input Port Description")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("in [double]:")]),e._v(" The incoming signal.")])]),e._v(" "),a("h2",{attrs:{id:"output-port-description"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#output-port-description","aria-hidden":"true"}},[e._v("#")]),e._v(" Output Port Description")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("top:")]),e._v(" The peak value of the signal.")]),e._v(" "),a("li",[a("strong",[e._v("bottom:")]),e._v(" The bottom value of the signal.")]),e._v(" "),a("li",[a("strong",[e._v("time:")]),e._v(" The time in ms or beats per minute (BPM) (depending on the property timeMode) between two peaks (Mode=detect tops), two valleys (Mode=detect bottoms) or a valley and a peak (Mode=detect both) depending on the selected mode in the properties.")])]),e._v(" "),a("h2",{attrs:{id:"event-trigger-description"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#event-trigger-description","aria-hidden":"true"}},[e._v("#")]),e._v(" Event Trigger Description")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("topDetected:")]),e._v(" The event gets fired if a new top value was detected in the input signal.")]),e._v(" "),a("li",[a("strong",[e._v("bottomDetected:")]),e._v(" The event gets fired if a new bottom value was detected in the input signal.")])]),e._v(" "),a("h2",{attrs:{id:"properties"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#properties","aria-hidden":"true"}},[e._v("#")]),e._v(" Properties")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("mode:")]),e._v(" Determines which time frame will be used for the time output signal (see description of the output port time).")]),e._v(" "),a("li",[e._v("**comparePeaks:**the number of top / bottom values which are taken into account for averaging (0 = disable)")]),e._v(" "),a("li",[e._v("**validTopPercentage:**the percentage of the recent averaged top values which constitutes a valid top value (0 = all top values are valid)")]),e._v(" "),a("li",[e._v("**validBottomPercentage:**the percentage of the recent averaged bottom values which constitutes a valid bottom value (0 = all bottom values are valid)")]),e._v(" "),a("li",[a("strong",[e._v("timeMode:")]),e._v(" Determines the unit for the measured time frame between top/bottom values. Options are beats per minute (BPM) or milliseconds.")])])])}],!1,null,null,null);r.options.__file="PeakDetector.md";t.default=r.exports}}]);